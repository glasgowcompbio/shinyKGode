library(shiny)
library(gridExtra)
library(ggplot2)
library(reshape2)
library(libSBML)

source('scripts/rkhs_gradmatch_wrapper.r')

SEED = 19537
set.seed(SEED)
modelChoices = c("---" = "",
                 "Lotka-Volterra" = "lv",
                 "Fiz hugh Nagumo" = "fhg",
                 "Biopathway" = "bp")

shinyServer(function(input, output, session) {
   
    observeEvent(input$process, {
        insertUI(
            selector = "#add",
            where = "afterEnd",
            ui = textInput(paste0("txt", input$add),
                           "Insert some text")
        )
    })    

    values <- reactiveValues(
        model_from = NULL,
        data_from = NULL,
        infer_res = NULL,
        df = NULL,
        kkk0 = NULL
    )    
        
    getModel = reactive({

        if (is.null(values$model_from)) {
            res = NULL
        } else if (values$model_from == 'uploaded') {
            res = get_initial_values_sbml(input$sbml_file)
        } else if (values$model_from == 'selected') {
            res = get_initial_values_selected(input$selected_model)
        }
        return(res)

    })
    
    resetScreen = function(input, output) {
        removeUI(selector = '#placeholderParams *', multiple=TRUE)
    }
    
    showModel = function(input, output, 
                         numSpecies, species, speciesInitial,
                         numParams, params, paramsVals) {

        removeUI(selector = '#placeholderParams *', multiple=TRUE)
        removeUI(selector = '#placeholderStates *', multiple=TRUE)
        
        output$odeParameters = renderText({ paste(params, collapse=", " ) })        
        for (i in 1:numParams) {
            paramValId = paste0('param_val', i)
            paramValLabel = params[i]
            insertUI(
                selector = '#placeholderParams',
                ui = fluidRow(
                    column(12, numericInput(paramValId, paramValLabel, value=paramsVals[i], min=0, max=NA, step=1))
                )                    
            )
        }
        
        labels = c()
        for (i in 1:numSpecies) {
            initCondId = paste0('initial_cond', i)
            initCondLabel = paste0(species[i], " Initial Cond.")
            guessId = paste0('p0_', i)
            guessLabel = 'Guess Period'
            insertUI(
                selector = '#placeholderStates',
                ui = fluidRow(
                    column(6, numericInput(initCondId, initCondLabel, value=speciesInitial[i], min=0, max=NA, step=0.1)),
                    column(6, numericInput(guessId, guessLabel, value=6, min=0, max=NA, step=0.1))
                )                    
            )
            labels = c(labels, species[i])
        }
        output$systemStates = renderText({ paste(labels, collapse=", " ) })
        
    }
    
    observeEvent(input$selected_model, {

        values$model_from <- 'selected'
        res = getModel()
        
        if (!is.null(res)) { # load one of the three pre-defined models, null otherwise
            showModel(input, output, 
                      res$numSpecies, res$species, res$speciesInitial, 
                      res$numParams, res$params, res$paramsVals)
        } else { # no predefined model is selected
            resetScreen(input, output)
        }
        
    })
    
    observeEvent(input$sbml_file, {

        values$model_from <- 'uploaded'
        sbml = getModel()
        showModel(input, output, 
                  sbml$numSpecies, sbml$species, sbml$speciesInitial, 
                  sbml$numParams, sbml$params, sbml$paramsVals)

    })    
    
    get_values = function(input, id, n, param_names) {
        vals = numeric(0)
        for (i in 1:n) {
            vals = c(vals, input[[paste0(id, i)]])
        }
        names(vals) = param_names
        return(vals)
    }
    
    getData = reactive({

        SEED = input$seed
        # print(paste('Get data seed is', SEED))
        set.seed(SEED)
        
        model = getModel()
        params = get_values(input, 'param_val', model$numParams, model$params)
        
        if (is.null(values$data_from)) { # should never happen
            
            res = NULL
            
        } else if (values$data_from == 'uploaded') { # for data uploaded by the user

            res = get_data_from_csv(input$csv_file$datapath, input$sbml_file$datapath, 
                                    params, values$model_from, input$selected_model)
            
        } else if (values$data_from == 'generated') { # for data generated by the user

            xinit = as.matrix(get_values(input, 'initial_cond', model$numSpecies, model$species))
            tinterv = c(input$timePointsMin, input$timePointsMax)
            res = generate_data(values$model_from, input$sbml_file$datapath, input$selected_model, 
                                xinit, tinterv, input$noise, input$noise_unit, 
                                model$numSpecies, params)

        }
        
        values$kkk0 = res$kkk0
        return(res)
        
    })
    
    showData = function(input, output, session, t, y_no) {
        
        model = getModel()
        
        updateTabsetPanel(session, "inTabset", selected="results")
        output$resultsPlot = renderPlot({
            
            plot_df = data.frame(y_no)
            plot_df$time = t
            plot_df = melt(plot_df, id.vars='time', variable.name='state')
            
            pp = list()
            for (i in 1:ncol(y_no)) {
                
                species = model$species[i]
                title = paste('State', species, sep=' ')
                pp[[i]] = ggplot(data=plot_df, aes(x=time, y=value)) + 
                    geom_point(data=subset(plot_df, state==species), color="red") + 
                    ggtitle(title) + 
                    theme_bw() + theme(text = element_text(size=20)) + 
                    expand_limits(x = 0) + scale_x_continuous(expand = c(0, 0))
                
            }
            do.call(grid.arrange, pp)
            
        })    
        
        shinyjs::enable("inferBtn")
        if (values$data_from == 'generated') {
            output$resultsType = renderText({ "Generated data:" })
            updateActionButton(session, "inferBtn", label = "Infer on generated data")    
            shinyjs::show("downloadDataBtn")
        } else if (values$data_from == 'uploaded') {
            output$resultsType = renderText({ "Loaded data:" })
            updateActionButton(session, "inferBtn", label = "Infer on loaded data")    
        }
        
        output$downloadDataBtn <- downloadHandler(
            filename = function() { 'data.csv' },
            content = function(file) {
                df1 = as.data.frame(res$time)
                df2 = as.data.frame(res$y_no)
                names(df1) = 'time'
                names(df2) = model$species
                df = cbind(df1, df2)
                write.csv(df, file, row.names=FALSE)
            }
        )    
        
    }
    
    observeEvent(input$generateBtn, {
        values$data_from <- 'generated'
        res = getData()
        showData(input, output, session, res$time, res$y_no)
    })    
    
    observeEvent(input$csv_file, {
        values$data_from <- 'uploaded'
        res = getData()
        showData(input, output, session, res$time, res$y_no)
    })
    
    observeEvent(input$inferBtn, {
        
        SEED = input$seed
        # print(paste('Infer seed is', SEED))
        set.seed(SEED)
        
        shinyjs::disable("inferBtn")
        updateTabsetPanel(session, "inTabset", selected="results")        

        res = getData()
        kkk = res$kkk
        y_no = res$y_no
        tinterv = res$tinterv
        
        model = getModel()
        nst = model$numSpecies

        progress <- shiny::Progress$new()
        on.exit(progress$close())
        
        if (!is.null(res$sbml_data)) {
            attach(res$sbml_data)
        }
        
        if (input$ode_reg == 'on' && input$warping == 'on') {
            method = '3rd+warping'
        } else {
            if (input$ode_reg == 'on') {
                method = 'gm+3rd'
            } else if (input$warping == 'on') {
                method = 'warping'
            } else {
                method = 'gm'
            }
        }
        # print(paste('method =', method))

        if (method == "gm") {
            infer_res = gradient_match(kkk, tinterv, y_no, input$ktype, progress)
        } else if (method == "gm+3rd") {
            infer_res = gradient_match_third_step(kkk, tinterv, y_no, input$ktype, progress)
        } else if (method == "warping") {
            peod = get_values(input, 'p0_', nst, model$species)
            eps = input$eps
            infer_res = warping(kkk, tinterv, y_no, peod, eps, input$ktype, progress)                
        } else if (method == "3rd+warping") {
            peod = get_values(input, 'p0_', nst, model$species)
            eps = input$eps
            infer_res = third_step_warping(kkk, tinterv, y_no, peod, eps, input$ktype, progress)                
        }
        
        # for plotting: solve the ode using the inferred parameters
        # params = get_values(input, 'param_val', model$numParams, model$params)
        params = infer_res$ode_par
        xinit = as.matrix(get_values(input, 'initial_cond', model$numSpecies, model$species))
        solved = values$kkk0$solve_ode(par_ode=params, xinit, tinterv)
        solved_yode = values$kkk0$y_ode
        solved_t = values$kkk0$t
        
        df = data.frame(parameters=infer_res$ode_par)
        rownames(df) = model$params

        values$infer_res = infer_res
        values$df = df
                    
        if (!is.null(res$sbml_data)) {
            detach(res$sbml_data)
        }

        output$diagnosticPlot = renderPlot({

            res = values$infer_res
            objectives = res$objectives

            # plot the objective function for gradient matching
            df = as.data.frame(objectives)
            iterations = seq_along(objectives)-1
            g = ggplot(data=df, aes(y=objectives, x=iterations)) +
                geom_line(size=1) +
                geom_point() +
                ggtitle('Optimisation Results') +
                xlab("Iteration") +
                ylab("Objective (f)") +
                theme_bw() + theme(text = element_text(size=20)) +
                expand_limits(x = 0) + scale_x_continuous(expand = c(0, 0))

            pp = list()
            pp[[1]] = g

            # plot the warping functions for each state, if we have them
            if (!is.null(res$warpfun_x[[1]])) {
                
                for (i in 1:res$nst) {
                    
                    warpfun_x = res$warpfun_x[[i]]
                    warpfun_y = res$warpfun_y[[i]]
                    
                    title = paste('State', model$species[i], ' - Warping', sep=' ')
                    warp_df = as.data.frame(warpfun_x)
                    warp_df$warpfun_y = warpfun_y
                    g = ggplot() +
                        geom_line(data=warp_df, aes(x=warpfun_x, y=warpfun_y), size=1) +
                        ggtitle(title) + 
                        theme_bw() + theme(text = element_text(size=20)) +
                        expand_limits(x = 0) + scale_x_continuous(expand = c(0, 0))
                    
                    pp[[i+1]] = g

                }
                
            }
                
            # show all the plots
            do.call(grid.arrange, pp)
            
        })
        
        output$console = renderPrint({
            return(values$infer_res$output)
        })
                
        output$resultsPlot = renderPlot({

            res = values$infer_res
            pp = list()
            for (i in 1:res$nst) {
                
                intp_x = res$intp_x[[i]]
                intp_y = res$intp_y[[i]]
                data_x = res$data_x[[i]]
                data_y = res$data_y[[i]]
                solved_y = solved_yode[i, ]
                solved_x = solved_t

                time = intp_x
                plot_df1 = data.frame(time)
                plot_df1$interpolated = intp_y
                plot_df1 = melt(plot_df1, id.vars='time', variable.name='type')
                
                time = data_x
                plot_df2 = data.frame(time)
                plot_df2$observed = data_y
                plot_df2 = melt(plot_df2, id.vars='time', variable.name='type')
                
                time = solved_x
                plot_df3 = data.frame(time)
                plot_df3$solved = solved_y
                plot_df3 = melt(plot_df3, id.vars='time', variable.name='type')
                
                plot_df = rbind(plot_df1, plot_df2, plot_df3)
                temp2 = subset(plot_df, type=='observed')
                temp1 = subset(plot_df, type=='interpolated')
                temp3 = subset(plot_df, type=='solved')
                
                title = paste('State', model$species[i], sep=' ')
                g = ggplot() + 
                    geom_point(data=temp2, aes(x=time, y=value, colour='c1')) +
                    geom_line(data=temp1, aes(x=time, y=value, colour='c2'), size=1) +
                    geom_line(data=temp3, aes(x=time, y=value, colour='c3'), size=1, linetype="dashed") + 
                    ggtitle(title) +
                    theme_bw() + theme(text = element_text(size=20)) +
                    scale_colour_manual(name="Legend", values=c(c1="red", c2="blue", c3="grey"), 
                                        labels=c(c1="Observed", c2="Interpolated", c3="Solved")) +
                    expand_limits(x = 0) + scale_x_continuous(expand = c(0, 0))
                
                pp[[i]] = g

            }
            do.call(grid.arrange, pp)

        })    
        
        output$resultsTable = renderTable({
            values$df
        }, rownames=T)
    
        shinyjs::show("downloadParamsBtn")
        shinyjs::enable("inferBtn")
        
        output$downloadParamsBtn <- downloadHandler(
            filename = function() { 'params.csv' },
            content = function(file) {
                write.csv(values$df, file)
            }
        )    
        
    })
    
})
